"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcClient = void 0;
const gRPC = __importStar(require("@grpc/grpc-js"));
const protoLoader = __importStar(require("@grpc/proto-loader"));
const delay = (delay, fn) => {
    return setTimeout(fn, delay || 0);
};
const clearDelay = (id) => {
    clearTimeout(id);
};
class RpcClient {
    constructor(options) {
        this.subscribers = new Map();
        this.verbose = false;
        this.isConnected = false;
        this.connectCBs = [];
        this.connectFailureCBs = [];
        this.errorCBs = [];
        this.disconnectCBs = [];
        const defaultOptions = {
            protoPath: __dirname + "/messages.proto",
            host: "localhost:16210",
            reconnect: true,
            verbose: false,
            uid: (Math.random() * 1000).toFixed(0),
            disableConnectionCheck: false,
        };
        this.options = {
            ...defaultOptions,
            ...options,
        };
        this.pending = {};
    }
    getServiceClient() {
        const { protoPath } = this.options;
        const packageDefinition = protoLoader.loadSync(protoPath, {
            keepCase: true,
            longs: String,
            enums: String,
            defaults: true,
            oneofs: true,
        });
        const proto = gRPC.loadPackageDefinition(packageDefinition);
        this.proto = proto.protowire;
        const { RPC } = proto.protowire;
        return RPC;
    }
    async connect() {
        this.options.reconnect = true;
        return this._connect();
    }
    async _connect() {
        this.log("gRPC Client connecting to", this.options.host);
        if (!this.client) {
            const RPC = this.getServiceClient();
            this.client = new RPC(this.options.host, gRPC.credentials.createInsecure(), {
                "grpc.max_receive_message_length": -1,
                "grpc.enable_retries": 1,
                "grpc.keepalive_timeout_ms": 30000,
            });
        }
        else {
            return new Promise((resolve) => {
                this.onConnect(resolve);
            });
        }
        return this._connectClient();
    }
    _reconnect(reason) {
        this._setConnected(false);
        if (this.reconnectDelay) {
            clearDelay(this.reconnectDelay);
            delete this.reconnectDelay;
        }
        this.clearPending(reason);
        delete this.stream;
        if (this.options.reconnect) {
            this.reconnectDelay = delay(1000, () => {
                this._connectClient();
            });
        }
    }
    async _connectClient() {
        const deadline = new Date();
        deadline.setSeconds(deadline.getSeconds() + 2);
        return new Promise((resolve) => {
            this.client.waitForReady(deadline, (connect_error) => {
                if (connect_error) {
                    this._reconnect("client connect deadline reached");
                    return resolve(false);
                }
                this.log("client connected");
                this.stream = this.createStream();
                this.initIntake(this.stream);
                this.stream.on("error", (error) => {
                    this.errorCBs.forEach((fn) => fn(error.toString(), error));
                    this.log("stream:error", error);
                    this._reconnect(error);
                });
                this.stream.on("end", (...args) => {
                    this.log("stream:end", ...args);
                    this._reconnect("stream end");
                });
                if (this.options.disableConnectionCheck)
                    return resolve(true);
                delay(100, async () => {
                    const response = await this.call("getVirtualSelectedParentBlueScoreRequest", {}).catch((e) => {
                        this.connectFailureCBs.forEach((fn) => fn(e));
                    });
                    this.log("getVirtualSelectedParentBlueScoreRequest:response", response);
                    if (response && response.blueScore) {
                        this._setConnected(true);
                    }
                    return resolve(true);
                });
            });
        });
    }
    _setConnected(isConnected) {
        if (this.isConnected == isConnected)
            return;
        this.isConnected = isConnected;
        const cbs = isConnected ? this.connectCBs : this.disconnectCBs;
        cbs.forEach((fn) => {
            fn();
        });
    }
    onConnect(callback) {
        this.connectCBs.push(callback);
        if (this.isConnected)
            callback();
    }
    onConnectFailure(callback) {
        this.connectFailureCBs.push(callback);
    }
    onError(callback) {
        this.errorCBs.push(callback);
    }
    onDisconnect(callback) {
        this.disconnectCBs.push(callback);
    }
    disconnect() {
        if (this.reconnectDelay) {
            clearDelay(this.reconnectDelay);
            delete this.reconnectDelay;
        }
        this.options.reconnect = false;
        this.stream && this.stream.end();
        this.client && this.client.close();
        this.clearPending();
    }
    clearPending(reason) {
        Object.keys(this.pending).forEach((key) => {
            const list = this.pending[key];
            list.forEach((o) => o.reject(reason || "closing by force"));
            this.pending[key] = [];
        });
    }
    createStream() {
        if (!this.client)
            return null;
        const stream = this.client.MessageStream(() => { });
        return stream;
    }
    initIntake(stream) {
        stream.on("data", (data) => {
            if (data.payload) {
                const name = data.payload;
                const payload = data[name];
                const ident = name.replace(/^get|Response$/gi, "").toLowerCase();
                this.handleIntake({ name, payload, ident });
            }
        });
    }
    handleIntake(o) {
        if (this.intakeHandler) {
            this.intakeHandler(o);
        }
        else {
            const handlers = this.pending[o.name];
            this.log("intake:", o, "handlers:", handlers);
            if (handlers && handlers.length) {
                const pending = handlers.shift();
                if (pending)
                    pending.resolve(o.payload);
            }
            const subscribers = this.subscribers.get(o.name);
            if (subscribers) {
                subscribers.map((subscriber) => {
                    subscriber.callback(o.payload);
                });
            }
        }
    }
    setIntakeHandler(fn) {
        this.intakeHandler = fn;
    }
    post(name, args = {}) {
        if (!this.stream)
            return false;
        const req = {
            [name]: args,
        };
        this.log("post:", req);
        this.stream.write(req);
        return true;
    }
    call(method, data) {
        this.log("call to", method);
        if (!this.client)
            return Promise.reject("not connected");
        return new Promise((resolve, reject) => {
            const stream = this.stream;
            if (!stream) {
                this.log("could not create stream");
                return reject("not connected");
            }
            const resp = method.replace(/Request$/, "Response");
            if (!this.pending[resp])
                this.pending[resp] = [];
            const handlers = this.pending[resp];
            handlers.push({ method, data, resolve, reject });
            this.post(method, data);
        });
    }
    subscribe(subject, data = {}, callback) {
        if (typeof data == "function") {
            callback = data;
            data = {};
        }
        this.log("subscribe to", subject);
        if (!this.client)
            return Promise.reject("not connected");
        const eventName = this.subjectToEventName(subject);
        this.log("subscribe:eventName", eventName);
        let subscribers = this.subscribers.get(eventName);
        if (!subscribers) {
            subscribers = [];
            this.subscribers.set(eventName, subscribers);
        }
        const uid = (Math.random() * 100000 + Date.now()).toFixed(0);
        subscribers.push({ uid, callback });
        const p = this.call(subject, data);
        p.uid = uid;
        return p;
    }
    subjectToEventName(subject) {
        const eventName = subject
            .replace("notify", "")
            .replace("Request", "Notification");
        return eventName[0].toLowerCase() + eventName.substr(1);
    }
    unSubscribe(subject, uid = "") {
        const eventName = this.subjectToEventName(subject);
        let subscribers = this.subscribers.get(eventName);
        if (!subscribers)
            return;
        if (!uid) {
            this.subscribers.delete(eventName);
        }
        else {
            subscribers = subscribers.filter((sub) => sub.uid != uid);
            this.subscribers.set(eventName, subscribers);
        }
    }
    log(message, ...args) {
        if (!this.options.verbose)
            return;
        const logMessage = `[Kaspa gRPC ${this.options.uid}]:`;
        console.log(logMessage, message, ...args);
    }
}
exports.RpcClient = RpcClient;
