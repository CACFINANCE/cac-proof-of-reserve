"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = exports.Config = void 0;
const kaspa_wasm_1 = require("../wasm/kaspa_wasm");
const Account_1 = require("./Account");
const Utils_1 = require("./Utils");
exports.Config = {
    DEFAULT_FEE: 0n,
    DEFAULT_COMPOUND_FEE: 1000000n,
    SCAN_BATCH_SIZE: 50,
    MAX_SCAN_SIZE: 5000,
};
class Wallet {
    constructor(clientProvider) {
        this.clientProvider = clientProvider;
        const xPrv = new kaspa_wasm_1.XPrv(kaspa_wasm_1.Mnemonic.random().toSeed(""));
        this.root = xPrv.intoString("xprv");
    }
    /**
     * Initialize a `Wallet` object from mnemonic pharse
     */
    static fromPhrase(clientProvider, phrase) {
        const wallet = new Wallet(clientProvider);
        const xPrv = new kaspa_wasm_1.XPrv(new kaspa_wasm_1.Mnemonic(phrase).toSeed(""));
        wallet.setRoot(xPrv.intoString("xprv"));
        return wallet;
    }
    /**
     * Initialize a `Wallet` object from seed (without password)
     */
    static fromSeed(clientProvider, seed) {
        const wallet = new Wallet(clientProvider);
        const xPrv = new kaspa_wasm_1.XPrv(seed);
        wallet.setRoot(xPrv.intoString("xprv"));
        return wallet;
    }
    /**
     * Initialize a `Wallet` object from private key string
     */
    static fromPrivateKey(clientProvider, xPrv) {
        if (!xPrv) {
            throw new Error("Private key should not be empty");
        }
        const wallet = new Wallet(clientProvider);
        wallet.setRoot(xPrv);
        return wallet;
    }
    /**
     * Return a random mnemonic phrase that can be used to initialize a wallet
     */
    static randomMnemonic() {
        const mnemonic = kaspa_wasm_1.Mnemonic.random();
        return {
            phrase: mnemonic.phrase,
            entropy: mnemonic.entropy,
        };
    }
    /**
     * Set `xPrv` of the wallet, you don't have to explicitly call this,
     * as it's used by factory methods
     */
    setRoot(xPrv) {
        this.root = xPrv;
    }
    /**
     * Return a `Account` object from this wallet, given the account `index`
     */
    async account(index = 0n) {
        const xPublicKey = await Utils_1.Utils.getXPublicKey(this.root, index);
        const xPrivateKey = await Utils_1.Utils.getXPrivateKey(this.root, index);
        return new Account_1.Account(this.clientProvider, index, xPublicKey, xPrivateKey);
    }
}
exports.Wallet = Wallet;
